# Title: npm-publish.yml
#
# Description:
# This script is designed to publish Unity packages to the GitLab npm package registry.
# It is used in a GitLab CI/CD pipeline.
# It consists of four main stages:
#     1. fetch: Fetch the CI scripts from the ci-scripts repository.
#     2. prepare: Prepare the package for publishing.
#     3. update: Update the changelog based on the new version number.
#     4. release: Publish the package to the GitLab npm package registry.
#
# Features:
#     - Copies necessary files for Unity custom packages, README.md, and CHANGELOG.md to create a distribution directory.
#     - Automatically updates the version based on the versionBumpHint in package.json.
#     - Automatically increments the version by comparing it with the already published version in the npm registry.
#     - Publishes the package to the GitLab npm package registry.
#     - Tags the commit with the new version number.

stages:
  - fetch
  - prepare
  - update
  - release

include:
  - .gitlab/ci/templates/fetch/fetch-ci.yml
  - .gitlab/ci/templates/git/git-config.yml

variables:
  PACKAGE_NAME: "$CI_PACKAGE_NAME"
  PUBLISH_SOURCE_DIR: "Assets/${PACKAGE_NAME}"
  PACKAGE_JSON_PATH: "Assets/${PACKAGE_NAME}/package.json"
  CHANGELOG_FILE: "CHANGELOG.md"
  DIST_DIR: "dist"
  NPM_PROJECT_ID: "${CI_NPM_PROJECT_ID}"
  NPM_REGISTRY_URL: "https://${CI_SERVER_HOST}/api/v4/projects/${NPM_PROJECT_ID}/packages/npm/"

.npm_publish_before_script:
  variables: !reference [.git-config, variables]
  before_script:
    # Install git, configure GitLab CI job token, and update CA certificates.
    - !reference [.git-config, before_script]
    # Install necessary tools
    - |
      echo "ðŸ“¦ Install necessary tools for npm-publish..."
      apk add --no-cache jq curl bash > /dev/null 2>&1
      echo "ðŸ“¦ Tool Versions:"
      jq --version
      curl --version | head -n1
      echo "bash version $(bash --version | head -n1 | grep -oE '[0-9]+\.[0-9]+\.[0-9]+')"

fetch_ci_for_npm:
  # This job is responsible for fetching the CI scripts from the ci-scripts repository.
  # It clones the ci-scripts repository, copies the necessary files to the current directory.
  # This ensures that the latest CI scripts are always used.  stage: fetch
  stage: fetch
  image: "alpine:latest"
  extends:
    - .fetch_ci
  before_script:
    # Install git, configure GitLab CI job token, and update CA certificates.
    - !reference [.git-config, before_script]
  rules:
    # No need to run if the package name is not set.
    - if: '$CI_PACKAGE_NAME == ""'
      when: never
    # Execute only if the pipeline is triggered by a push to the default branch,
    # and the package.json file exists in the specified path.
    - if: >
        $CI_PIPELINE_SOURCE == "push" &&
        $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH
      exists:
        - "${PACKAGE_JSON_PATH}"
      when: always
    # Manual trigger only for the default branch.
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH
      exists:
        - "${PACKAGE_JSON_PATH}"
      when: manual
      allow_failure: true

publish_upm_prepare:
  # This stage is preparing the package for publishing.
  # It copies the necessary files from the source directory to the dist directory.
  #     - Runtime/*:    Runtime files for the package.
  #     - Editor/*:     Editor files for the package.
  #     - Tests/*:      Test files for the package.
  #     - package.json: The package.json file for the package.
  #     - README.md:    The README file for the package.
  #     - CHANGELOG.md: The CHANGELOG file for the package.
  stage: prepare
  image: "alpine:latest"
  extends:
    - .npm_publish_before_script
  needs: [fetch_ci_for_npm]
  script:
    # Check if PACKAGE_NAME is set
    - |
      if [ -z "$PACKAGE_NAME" ]; then
        echo "âŒ PACKAGE_NAME is not set. Aborting."
        exit 1
      fi
    # Check if the package.json file exists in the specified path
    - echo "ðŸ” Checking for package.json..."
    - |
      if [ ! -f "$PACKAGE_JSON_PATH" ]; then
        echo "âš ï¸  $PACKAGE_JSON_PATH not found. Skipping publish."
        exit 0
      fi
    # Remove the dist directory if it exists and create a new one
    # Copy the necessary files to the dist directory
    - |
      echo "ðŸ§¹ Rebuilding $DIST_DIR..."
      rm -rf "$DIST_DIR" && mkdir -p "$DIST_DIR"
      cp "$PACKAGE_JSON_PATH" "$DIST_DIR/package.json"
      for f in README.md $CHANGELOG_FILE; do [ -f "$f" ] && cp "$f" "$DIST_DIR/" || echo "âš ï¸ $f missing"; done
      cp -r "$PUBLISH_SOURCE_DIR"/* "$DIST_DIR/" || echo "âš ï¸ No source files found in $PUBLISH_SOURCE_DIR"
      echo "âœ… $DIST_DIR rebuilt successfully."
  artifacts:
    name: "publish_upm_prepare"
    paths:
      - "$DIST_DIR"
    expire_in: 1 day
  rules:
    # No need to run if the package name is not set.
    - if: '$CI_PACKAGE_NAME == ""'
      when: never
    # Execute only if the pipeline is triggered by a push to the default branch,
    # and the package.json file exists in the specified path.
    - if: >
        $CI_PIPELINE_SOURCE == "push" &&
        $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH
      exists:
        - "${PACKAGE_JSON_PATH}"
      when: on_success
    # Manual trigger only for the default branch.
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH
      exists:
        - "${PACKAGE_JSON_PATH}"
      when: manual
      allow_failure: true

publish_upm_check_version:
  # This stage checks the version of the package to be published.
  # It compares the local version with the published version in the npm registry.
  # If the published version is ahead, it bumps the version based on the versionBumpHint in package.json.
  # If the published version is behind, it uses the local version.
  # It also updates the versionBumpHint in package.json to remove it after the version bump.
  # Finally, it saves the next version to a file for use in the publish stage.
  stage: prepare
  image: "alpine:latest"
  extends:
    - .npm_publish_before_script
  needs:
    - publish_upm_prepare
    - fetch_ci_for_npm
  script:
    # Run the version check and bump script
    - |
      echo "ðŸ” Checking version..."
      bash +x .gitlab/ci/scripts/npm/manage_package_version.sh "$DIST_DIR/package.json" "$DIST_DIR" "$NPM_REGISTRY_URL" "$NPM_TOKEN"
      echo "âœ… Version check and bump completed."
  artifacts:
    name: "publish_upm_check_version"
    paths:
      - .next_version
    expire_in: 1 day
  rules:
    # No need to run if the package name is not set.
    - if: '$CI_PACKAGE_NAME == ""'
      when: never
    # Execute only if the pipeline is triggered by a push to the default branch,
    # and the package.json file exists in the specified path.
    - if: >
        $CI_PIPELINE_SOURCE == "push" &&
        $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH
      exists:
        - "${PACKAGE_JSON_PATH}"
      when: on_success
    # Manual trigger only for the default branch.
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH
      exists:
        - "${PACKAGE_JSON_PATH}"
      when: manual
      allow_failure: true

update_changelog_for_npm:
  # This stage updates the changelog for the package.
  # It uses the version from the previous stage and updates the CHANGELOG.md file.
  # It commits the changes to the CHANGELOG.md file and pushes them to the repository.
  # It also creates a new tag for the release.
  # Finally, it pushes the changes to the main branch.
  stage: update
  image: "alpine:latest"
  extends:
    - .npm_publish_before_script
  needs:
    - fetch_ci_for_npm
    - publish_upm_prepare
    - publish_upm_check_version
  script:
    # Update CHANGELOG.md
    - |
      VERSION=$(cat .next_version)
      echo "ðŸš€ Updating changelog for version: $VERSION"
      bash +x .gitlab/ci/scripts/changelog/update_for_release.sh "$VERSION" "$CHANGELOG_FILE"
      cp $CHANGELOG_FILE "$DIST_DIR/$CHANGELOG_FILE"
    # Check for changes in the CHANGELOG.md, and commit if there are any.
    - |
      echo "ðŸ” Checking for changes in $CHANGELOG_FILE..."
      if [ -n "$(git ls-files --others --exclude-standard -- "$CHANGELOG_FILE")" ]; then
        echo "ðŸ†• $CHANGELOG_FILE is a new file. Committing..."
        git add $CHANGELOG_FILE
        git commit -m "docs(ci): add new changelog for tag v$VERSION [ci skip]"
        git push -o ci.skip origin HEAD:$CI_COMMIT_REF_NAME
        echo "ðŸš€ Changelog committed successfully (new file)"
      elif ! git diff --quiet "$CHANGELOG_FILE"; then
        echo "âœï¸ $CHANGELOG_FILE was modified. Committing..."
        git add $CHANGELOG_FILE
        git commit -m "docs(ci): update changelog for tag v$VERSION [ci skip]"
        git push -o ci.skip origin HEAD:$CI_COMMIT_REF_NAME
        echo "ðŸš€ Changelog updated successfully for version $VERSION"
      else
        echo "â„¹ï¸ No changes in $CHANGELOG_FILE, skipping commit."
        exit 0
      fi
  artifacts:
    name: "update_changelog_for_npm"
    paths:
      - .next_version
      - $CHANGELOG_FILE
      - $DIST_DIR
    expire_in: 1 day
  rules:
    # No need to run if the package name is not set.
    - if: '$CI_PACKAGE_NAME == ""'
      when: never
    # Execute only if the pipeline is triggered by a push to the default branch,
    # and the package.json file exists in the specified path.
    - if: >
        $CI_PIPELINE_SOURCE == "push" &&
        $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH
      exists:
        - "${PACKAGE_JSON_PATH}"
      when: on_success
    # Manual trigger only for the default branch.
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH
      exists:
        - "${PACKAGE_JSON_PATH}"
      when: manual
      allow_failure: true

publish_upm_publish:
  # This stage publishes the package to the GitLab npm package registry.
  # It uses the version from the previous stage and publishes the package.
  # It also tags the commit with the new version number.
  # Finally, it checks if package.json was modified and commits the changes if necessary.
  # It pushes the changes to the main branch.
  stage: release
  image: "node:18-alpine"
  extends:
    - .npm_publish_before_script
  needs: ["update_changelog_for_npm"]
  script:
    # Install necessary tools
    - |
      echo "ðŸ“¦ Tool Versions:"
      npm -v
    # Create .npmrc file for authentication with the GitLab npm registry.
    - |
      echo "ðŸ”‘ Creating .npmrc file..."
      NPMRC_PATH="$DIST_DIR/.npmrc"
      trap "rm -f $NPMRC_PATH" EXIT
      echo "@${CI_PROJECT_ROOT_NAMESPACE}:registry=${NPM_REGISTRY_URL}" > "$NPMRC_PATH"
      echo "//${CI_SERVER_HOST}/api/v4/projects/${NPM_PROJECT_ID}/packages/npm/:_authToken=${NPM_TOKEN}" >> "$NPMRC_PATH"
      echo "strict-ssl=false" >> "$NPMRC_PATH"
      echo "always-auth=true" >> "$NPMRC_PATH"
      npm config get @${CI_PROJECT_ROOT_NAMESPACE}:registry --userconfig "$NPMRC_PATH"
    # Authenticating with GitLab npm registry, testing publish with --dry-run
    - |
      echo "ðŸ§ª Testing publish with --dry-run..."
      cd "$DIST_DIR"
      if ! npm publish --dry-run --registry="$NPM_REGISTRY_URL" --userconfig "$NPMRC_PATH" > /dev/null; then
        echo "âŒ Dry-run failed. Check authentication and registry settings."
        exit 1
      fi
      cd "$CI_PROJECT_DIR"
    # release the package
    - |
      VERSION=$(cat .next_version)
      echo "ðŸš€ Publishing version: $VERSION"
    # Check if the release already exists
    - |
      if git ls-remote --tags origin | grep -q "refs/tags/v$VERSION"; then
        echo "ðŸš« Release v$VERSION already exists. Skipping release creation."
        exit 0
      fi
    # Commit and push the changes to package.json if it was modified
    - |
      echo "ðŸ” Checking if package.json was modified..."
      if git diff --quiet "$PACKAGE_JSON_PATH"; then
        echo "âœ… No changes to package.json"
      else
        echo "ðŸ’¡ Committing bumped package.json..."
        git add "$PACKAGE_JSON_PATH"
        git commit -m "chore(ci): bump version to v$VERSION [ci skip]"
        git push -o ci.skip origin "$CI_COMMIT_BRANCH"
      fi
    # Tags the current HEAD with the new version number.
    - |
      echo "ðŸ·ï¸ Tagging: v$VERSION"
      git tag "v$VERSION"
      git push -o ci.skip origin "v$VERSION"
    # Create .npmrc file for authentication with the GitLab npm registry
    - |
      echo "ðŸ“¦ Publishing to GitLab npm registry..."
      cd "$DIST_DIR"
      npm publish --registry="$NPM_REGISTRY_URL" --userconfig "$NPMRC_PATH"
      cd "$CI_PROJECT_DIR"
      echo "âœ… Published successfully!"
  artifacts:
    name: "publish_upm_publish"
    paths:
      - .next_version
      - $CHANGELOG_FILE
      - $DIST_DIR
    expire_in: 1 day
  rules:
    # No need to run if the package name is not set.
    - if: '$CI_PACKAGE_NAME == ""'
      when: never
    # Execute only if the pipeline is triggered by a push to the default branch,
    # and the package.json file exists in the specified path.
    - if: >
        $CI_PIPELINE_SOURCE == "push" &&
        $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH
      exists:
        - "${PACKAGE_JSON_PATH}"
      when: on_success
    # Manual trigger only for the default branch.
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH
      exists:
        - "${PACKAGE_JSON_PATH}"
      when: manual
      allow_failure: true
